{"ast":null,"code":"import axios from 'axios';\n\n// Parse decklist text into card objects\nexport const parseDecklist = decklistText => {\n  const lines = decklistText.trim().split('\\n');\n  const cards = [];\n  for (const line of lines) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine) continue;\n\n    // Match patterns like \"1x Lightning Bolt (2XM) 123\" or \"1 Lightning Bolt\"\n    const match = trimmedLine.match(/^(\\d+)(?:x\\s*)?(.+?)(?:\\s*\\(([^)]+)\\))?(?:\\s+\\d+)?$/);\n    if (match) {\n      const [, quantity, cardName, setCode] = match;\n      cards.push({\n        quantity: parseInt(quantity),\n        name: cardName.trim(),\n        setCode: setCode ? setCode.trim() : null\n      });\n    }\n  }\n  return cards;\n};\n\n// Convert image URL to base64 to avoid CORS issues\nconst convertImageToBase64 = async imageUrl => {\n  try {\n    // Create a canvas to convert the image\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    const img = new Image();\n\n    // Set crossOrigin to anonymous to handle CORS\n    img.crossOrigin = 'anonymous';\n    return new Promise((resolve, reject) => {\n      img.onload = () => {\n        canvas.width = img.width;\n        canvas.height = img.height;\n        ctx.drawImage(img, 0, 0);\n        try {\n          const dataURL = canvas.toDataURL('image/png');\n          resolve(dataURL);\n        } catch (error) {\n          console.error('Error converting image to base64:', error);\n          reject(error);\n        }\n      };\n      img.onerror = () => {\n        console.error('Error loading image:', imageUrl);\n        reject(new Error('Failed to load image'));\n      };\n      img.src = imageUrl;\n    });\n  } catch (error) {\n    console.error('Error in convertImageToBase64:', error);\n    throw error;\n  }\n};\n\n// Test function to verify API is working\nexport const testScryfallAPI = async () => {\n  try {\n    console.log('Testing Scryfall API...');\n\n    // Test 1: Simple card search\n    const response1 = await axios.get('https://api.scryfall.com/cards/search', {\n      params: {\n        q: '!\"Lightning Bolt\"',\n        unique: 'cards'\n      }\n    });\n    console.log('Test 1 (Lightning Bolt):', response1.data.data.length, 'results');\n\n    // Test 2: Set-specific search\n    const response2 = await axios.get('https://api.scryfall.com/cards/search', {\n      params: {\n        q: '!\"Lightning Bolt\" set:M11',\n        unique: 'cards'\n      }\n    });\n    console.log('Test 2 (Lightning Bolt M11):', response2.data.data.length, 'results');\n\n    // Test 3: Counterspell search\n    const response3 = await axios.get('https://api.scryfall.com/cards/search', {\n      params: {\n        q: '!\"Counterspell\"',\n        unique: 'cards'\n      }\n    });\n    console.log('Test 3 (Counterspell):', response3.data.data.length, 'results');\n    return true;\n  } catch (error) {\n    var _error$response, _error$response2;\n    console.error('API test failed:', (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status, (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.statusText);\n    return false;\n  }\n};\n\n// Fetch card data from Scryfall API\nexport const fetchCardData = async (cardName, setCode = null) => {\n  try {\n    // Always try name-only search first (most reliable)\n    console.log(`Searching for: !\"${cardName}\"`);\n    const response = await axios.get(`https://api.scryfall.com/cards/search`, {\n      params: {\n        q: `!\"${cardName}\"`,\n        unique: 'cards'\n      }\n    });\n    if (response.data.data && response.data.data.length > 0) {\n      var _card$image_uris, _card$card_faces, _card$card_faces$, _card$card_faces$$ima;\n      const card = response.data.data[0];\n      const imageUrl = ((_card$image_uris = card.image_uris) === null || _card$image_uris === void 0 ? void 0 : _card$image_uris.png) || ((_card$card_faces = card.card_faces) === null || _card$card_faces === void 0 ? void 0 : (_card$card_faces$ = _card$card_faces[0]) === null || _card$card_faces$ === void 0 ? void 0 : (_card$card_faces$$ima = _card$card_faces$.image_uris) === null || _card$card_faces$$ima === void 0 ? void 0 : _card$card_faces$$ima.png);\n      console.log(`Found ${cardName} in set ${card.set_name}`);\n\n      // Pre-load and convert image to base64 to avoid CORS issues\n      let base64Image = null;\n      try {\n        base64Image = await convertImageToBase64(imageUrl);\n        console.log(`Successfully converted ${cardName} image to base64`);\n      } catch (imageError) {\n        console.warn(`Failed to convert ${cardName} image to base64:`, imageError);\n        // Keep the original URL as fallback\n      }\n      return {\n        name: card.name,\n        imageUrl: imageUrl,\n        base64Image: base64Image,\n        // Store base64 version for PDF generation\n        set: card.set_name,\n        collectorNumber: card.collector_number\n      };\n    }\n    throw new Error(`Card not found: ${cardName}`);\n  } catch (error) {\n    var _error$response3, _error$response4;\n    console.error(`Error fetching card ${cardName}:`, (_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status, (_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.statusText);\n    throw new Error(`Card not found: ${cardName}`);\n  }\n};\n\n// Fetch multiple cards with error handling\nexport const fetchMultipleCards = async cards => {\n  const results = [];\n  const errors = [];\n  for (const card of cards) {\n    try {\n      const cardData = await fetchCardData(card.name, card.setCode);\n      // Add the card multiple times based on quantity\n      for (let i = 0; i < card.quantity; i++) {\n        results.push(cardData);\n      }\n    } catch (error) {\n      errors.push(`${card.name}: ${error.message}`);\n    }\n  }\n  return {\n    results,\n    errors\n  };\n};","map":{"version":3,"names":["axios","parseDecklist","decklistText","lines","trim","split","cards","line","trimmedLine","match","quantity","cardName","setCode","push","parseInt","name","convertImageToBase64","imageUrl","canvas","document","createElement","ctx","getContext","img","Image","crossOrigin","Promise","resolve","reject","onload","width","height","drawImage","dataURL","toDataURL","error","console","onerror","Error","src","testScryfallAPI","log","response1","get","params","q","unique","data","length","response2","response3","_error$response","_error$response2","response","status","statusText","fetchCardData","_card$image_uris","_card$card_faces","_card$card_faces$","_card$card_faces$$ima","card","image_uris","png","card_faces","set_name","base64Image","imageError","warn","set","collectorNumber","collector_number","_error$response3","_error$response4","fetchMultipleCards","results","errors","cardData","i","message"],"sources":["C:/MTG/mtg-pdf-printer/mtg-pdf-printer/src/utils/scryfall.js"],"sourcesContent":["import axios from 'axios';\r\n\r\n// Parse decklist text into card objects\r\nexport const parseDecklist = (decklistText) => {\r\n  const lines = decklistText.trim().split('\\n');\r\n  const cards = [];\r\n\r\n  for (const line of lines) {\r\n    const trimmedLine = line.trim();\r\n    if (!trimmedLine) continue;\r\n\r\n    // Match patterns like \"1x Lightning Bolt (2XM) 123\" or \"1 Lightning Bolt\"\r\n    const match = trimmedLine.match(/^(\\d+)(?:x\\s*)?(.+?)(?:\\s*\\(([^)]+)\\))?(?:\\s+\\d+)?$/);\r\n    \r\n    if (match) {\r\n      const [, quantity, cardName, setCode] = match;\r\n      cards.push({\r\n        quantity: parseInt(quantity),\r\n        name: cardName.trim(),\r\n        setCode: setCode ? setCode.trim() : null\r\n      });\r\n    }\r\n  }\r\n\r\n  return cards;\r\n};\r\n\r\n// Convert image URL to base64 to avoid CORS issues\r\nconst convertImageToBase64 = async (imageUrl) => {\r\n  try {\r\n    // Create a canvas to convert the image\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d');\r\n    const img = new Image();\r\n    \r\n    // Set crossOrigin to anonymous to handle CORS\r\n    img.crossOrigin = 'anonymous';\r\n    \r\n    return new Promise((resolve, reject) => {\r\n      img.onload = () => {\r\n        canvas.width = img.width;\r\n        canvas.height = img.height;\r\n        ctx.drawImage(img, 0, 0);\r\n        \r\n        try {\r\n          const dataURL = canvas.toDataURL('image/png');\r\n          resolve(dataURL);\r\n        } catch (error) {\r\n          console.error('Error converting image to base64:', error);\r\n          reject(error);\r\n        }\r\n      };\r\n      \r\n      img.onerror = () => {\r\n        console.error('Error loading image:', imageUrl);\r\n        reject(new Error('Failed to load image'));\r\n      };\r\n      \r\n      img.src = imageUrl;\r\n    });\r\n  } catch (error) {\r\n    console.error('Error in convertImageToBase64:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Test function to verify API is working\r\nexport const testScryfallAPI = async () => {\r\n  try {\r\n    console.log('Testing Scryfall API...');\r\n    \r\n    // Test 1: Simple card search\r\n    const response1 = await axios.get('https://api.scryfall.com/cards/search', {\r\n      params: { q: '!\"Lightning Bolt\"', unique: 'cards' }\r\n    });\r\n    console.log('Test 1 (Lightning Bolt):', response1.data.data.length, 'results');\r\n    \r\n    // Test 2: Set-specific search\r\n    const response2 = await axios.get('https://api.scryfall.com/cards/search', {\r\n      params: { q: '!\"Lightning Bolt\" set:M11', unique: 'cards' }\r\n    });\r\n    console.log('Test 2 (Lightning Bolt M11):', response2.data.data.length, 'results');\r\n    \r\n    // Test 3: Counterspell search\r\n    const response3 = await axios.get('https://api.scryfall.com/cards/search', {\r\n      params: { q: '!\"Counterspell\"', unique: 'cards' }\r\n    });\r\n    console.log('Test 3 (Counterspell):', response3.data.data.length, 'results');\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('API test failed:', error.response?.status, error.response?.statusText);\r\n    return false;\r\n  }\r\n};\r\n\r\n// Fetch card data from Scryfall API\r\nexport const fetchCardData = async (cardName, setCode = null) => {\r\n  try {\r\n    // Always try name-only search first (most reliable)\r\n    console.log(`Searching for: !\"${cardName}\"`);\r\n    \r\n    const response = await axios.get(`https://api.scryfall.com/cards/search`, {\r\n      params: {\r\n        q: `!\"${cardName}\"`,\r\n        unique: 'cards'\r\n      }\r\n    });\r\n\r\n    if (response.data.data && response.data.data.length > 0) {\r\n      const card = response.data.data[0];\r\n      const imageUrl = card.image_uris?.png || card.card_faces?.[0]?.image_uris?.png;\r\n      \r\n      console.log(`Found ${cardName} in set ${card.set_name}`);\r\n      \r\n      // Pre-load and convert image to base64 to avoid CORS issues\r\n      let base64Image = null;\r\n      try {\r\n        base64Image = await convertImageToBase64(imageUrl);\r\n        console.log(`Successfully converted ${cardName} image to base64`);\r\n      } catch (imageError) {\r\n        console.warn(`Failed to convert ${cardName} image to base64:`, imageError);\r\n        // Keep the original URL as fallback\r\n      }\r\n      \r\n      return {\r\n        name: card.name,\r\n        imageUrl: imageUrl,\r\n        base64Image: base64Image, // Store base64 version for PDF generation\r\n        set: card.set_name,\r\n        collectorNumber: card.collector_number\r\n      };\r\n    }\r\n    \r\n    throw new Error(`Card not found: ${cardName}`);\r\n  } catch (error) {\r\n    console.error(`Error fetching card ${cardName}:`, error.response?.status, error.response?.statusText);\r\n    throw new Error(`Card not found: ${cardName}`);\r\n  }\r\n};\r\n\r\n// Fetch multiple cards with error handling\r\nexport const fetchMultipleCards = async (cards) => {\r\n  const results = [];\r\n  const errors = [];\r\n\r\n  for (const card of cards) {\r\n    try {\r\n      const cardData = await fetchCardData(card.name, card.setCode);\r\n      // Add the card multiple times based on quantity\r\n      for (let i = 0; i < card.quantity; i++) {\r\n        results.push(cardData);\r\n      }\r\n    } catch (error) {\r\n      errors.push(`${card.name}: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  return { results, errors };\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { PDFDocument, rgb } from 'pdf-lib';\n\n// MTGPrint default settings for Letter paper (8.5\" x 11\") at 300 DPI\n// Letter page: 8.5\" x 11\" = 2550 x 3300 pixels at 300 DPI\nconst LETTER_WIDTH_INCHES = 8.5;\nconst LETTER_HEIGHT_INCHES = 11.0;\nconst DPI = 300;\n\n// Standard Magic card dimensions: 2.5\" x 3.5\" = 750 x 1050 pixels at 300 DPI\nconst CARD_WIDTH_INCHES = 2.5;\nconst CARD_HEIGHT_INCHES = 3.5;\n\n// Convert to points (1 inch = 72 points)\nconst POINTS_PER_INCH = 72;\n\n// Page dimensions in points\nconst PAGE_WIDTH_POINTS = LETTER_WIDTH_INCHES * POINTS_PER_INCH; // 612pt\nconst PAGE_HEIGHT_POINTS = LETTER_HEIGHT_INCHES * POINTS_PER_INCH; // 792pt\n\n// Card dimensions in points\nconst CARD_WIDTH_POINTS = CARD_WIDTH_INCHES * POINTS_PER_INCH; // 180pt\nconst CARD_HEIGHT_POINTS = CARD_HEIGHT_INCHES * POINTS_PER_INCH; // 252pt\n\n// Calculate margins to center 3x3 grid on Letter page\n// Total grid width: 3 cards * 180pt = 540pt\n// Total grid height: 3 cards * 252pt = 756pt\n// Available space: 612pt x 792pt\n// Margins: (612 - 540) / 2 = 36pt horizontal, (792 - 756) / 2 = 18pt vertical\n\nexport const generatePDF = async (cards, paper = {\n  width: 8.5,\n  height: 11.0\n}, scale = 100, options = {}) => {\n  // Use default Letter paper dimensions\n  const pageWidth = PAGE_WIDTH_POINTS;\n  const pageHeight = PAGE_HEIGHT_POINTS;\n\n  // Apply scale factor (90-110% range)\n  const scaleFactor = Math.max(90, Math.min(Number(scale), 110)) / 100;\n  const cardWidth = CARD_WIDTH_POINTS * scaleFactor;\n  const cardHeight = CARD_HEIGHT_POINTS * scaleFactor;\n\n  // Recalculate margins for scaled cards to maintain centering\n  const scaledMarginX = (pageWidth - 3 * cardWidth) / 2;\n  const scaledMarginY = (pageHeight - 3 * cardHeight) / 2;\n  const pdfDoc = await PDFDocument.create();\n\n  // Pre-fetch all images as Uint8Array\n  const imageBytesArr = await Promise.all(cards.map(async card => {\n    try {\n      const response = await fetch(card.imageUrl);\n      const arrayBuffer = await response.arrayBuffer();\n      return new Uint8Array(arrayBuffer);\n    } catch (error) {\n      console.error(`Failed to fetch image for ${card.name}:`, error);\n      return null;\n    }\n  }));\n\n  // Process cards in groups of 9 (3x3 grid per page)\n  for (let i = 0; i < cards.length; i += 9) {\n    const pageCards = cards.slice(i, i + 9);\n    const pageImages = imageBytesArr.slice(i, i + 9);\n    const page = pdfDoc.addPage([pageWidth, pageHeight]);\n\n    // Add black corners if enabled (draw before card images so they appear behind)\n    if (options.blackCorners) {\n      // Black corner dimensions: small squares at each corner (6-8px equivalent)\n      const CORNER_SIZE = 0.0625 * POINTS_PER_INCH; // 4.5pt (~6px at 300 DPI)\n\n      // Draw black corners for each card on the page\n      for (let j = 0; j < pageCards.length; j++) {\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n\n        // Calculate card position\n        const cardX = scaledMarginX + col * cardWidth;\n        const cardY = pageHeight - scaledMarginY - cardHeight - row * cardHeight;\n\n        // Draw black corners at each corner of the card\n        // Top-left corner - positioned so inner corner touches card corner\n        page.drawRectangle({\n          x: cardX - CORNER_SIZE,\n          y: cardY + cardHeight,\n          width: CORNER_SIZE,\n          height: CORNER_SIZE,\n          borderWidth: 0,\n          color: rgb(0, 0, 0)\n        });\n\n        // Top-right corner - positioned so inner corner touches card corner\n        page.drawRectangle({\n          x: cardX + cardWidth,\n          y: cardY + cardHeight,\n          width: CORNER_SIZE,\n          height: CORNER_SIZE,\n          borderWidth: 0,\n          color: rgb(0, 0, 0)\n        });\n\n        // Bottom-left corner - positioned so inner corner touches card corner\n        page.drawRectangle({\n          x: cardX - CORNER_SIZE,\n          y: cardY - CORNER_SIZE,\n          width: CORNER_SIZE,\n          height: CORNER_SIZE,\n          borderWidth: 0,\n          color: rgb(0, 0, 0)\n        });\n\n        // Bottom-right corner - positioned so inner corner touches card corner\n        page.drawRectangle({\n          x: cardX + cardWidth,\n          y: cardY - CORNER_SIZE,\n          width: CORNER_SIZE,\n          height: CORNER_SIZE,\n          borderWidth: 0,\n          color: rgb(0, 0, 0)\n        });\n      }\n    }\n\n    // Place cards in 3x3 grid, left-to-right, top-to-bottom\n    for (let j = 0; j < pageCards.length; j++) {\n      const imgBytes = pageImages[j];\n      if (!imgBytes) continue; // Skip if image failed to load\n\n      try {\n        // Embed image (assume PNG)\n        const img = await pdfDoc.embedPng(imgBytes);\n\n        // Calculate grid position (0-2 for row and column)\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n\n        // Calculate card position (PDF coordinates: bottom-left origin)\n        const x = scaledMarginX + col * cardWidth;\n        const y = pageHeight - scaledMarginY - cardHeight - row * cardHeight;\n\n        // Draw the card image\n        page.drawImage(img, {\n          x,\n          y,\n          width: cardWidth,\n          height: cardHeight\n        });\n      } catch (error) {\n        console.error(`Failed to embed image for ${pageCards[j].name}:`, error);\n      }\n    }\n\n    // Add crop marks if enabled\n    if (options.cropMarks) {\n      // Crop mark dimensions: 1/4\" long, 0.5pt wide for thinner marks\n      const CROP_MARK_LENGTH = 0.25 * POINTS_PER_INCH; // 18pt (1/4\")\n      const CROP_MARK_THICKNESS = 0.5; // 0.5pt wide for thinner crop marks\n\n      // Draw crop marks for each card on the page\n      for (let j = 0; j < pageCards.length; j++) {\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n\n        // Calculate card position\n        const cardX = scaledMarginX + col * cardWidth;\n        const cardY = pageHeight - scaledMarginY - cardHeight - row * cardHeight;\n\n        // Calculate crop mark offset for outermost edges\n        const isRightmostCard = col === 2; // Rightmost column (0-indexed)\n        const isBottomCard = row === 2; // Bottom row (0-indexed)\n        const cropMarkOffset = CROP_MARK_THICKNESS - 0.75; // Reduced offset (moved back by ~1 pixel)\n        const rightCropMarkOffset = 0.375; // Additional 0.5 pixel offset for right crop marks\n\n        // Draw crop marks at each corner of the card\n        // Top-left corner (always standard position)\n        page.drawLine({\n          start: {\n            x: cardX - CROP_MARK_LENGTH,\n            y: cardY + cardHeight\n          },\n          end: {\n            x: cardX,\n            y: cardY + cardHeight\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: {\n            x: cardX,\n            y: cardY + cardHeight + CROP_MARK_LENGTH\n          },\n          end: {\n            x: cardX,\n            y: cardY + cardHeight\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n\n        // Top-right corner (offset outward if rightmost card)\n        const rightEdgeX = isRightmostCard ? cardX + cardWidth + cropMarkOffset + rightCropMarkOffset : cardX + cardWidth;\n        page.drawLine({\n          start: {\n            x: rightEdgeX,\n            y: cardY + cardHeight\n          },\n          end: {\n            x: rightEdgeX + CROP_MARK_LENGTH,\n            y: cardY + cardHeight\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: {\n            x: rightEdgeX,\n            y: cardY + cardHeight + CROP_MARK_LENGTH\n          },\n          end: {\n            x: rightEdgeX,\n            y: cardY + cardHeight\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n\n        // Bottom-left corner (offset outward if bottom card)\n        const bottomEdgeY = isBottomCard ? cardY - cropMarkOffset : cardY;\n        page.drawLine({\n          start: {\n            x: cardX - CROP_MARK_LENGTH,\n            y: bottomEdgeY\n          },\n          end: {\n            x: cardX,\n            y: bottomEdgeY\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: {\n            x: cardX,\n            y: bottomEdgeY - CROP_MARK_LENGTH\n          },\n          end: {\n            x: cardX,\n            y: bottomEdgeY\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n\n        // Bottom-right corner (offset outward if rightmost AND bottom card)\n        page.drawLine({\n          start: {\n            x: rightEdgeX,\n            y: bottomEdgeY\n          },\n          end: {\n            x: rightEdgeX + CROP_MARK_LENGTH,\n            y: bottomEdgeY\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: {\n            x: rightEdgeX,\n            y: bottomEdgeY - CROP_MARK_LENGTH\n          },\n          end: {\n            x: rightEdgeX,\n            y: bottomEdgeY\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n      }\n    }\n  }\n  const pdfBytes = await pdfDoc.save();\n  return new Blob([pdfBytes], {\n    type: 'application/pdf'\n  });\n};\nexport const downloadPDF = (pdfBlob, filename = 'mtg-deck.pdf') => {\n  const url = URL.createObjectURL(pdfBlob);\n  const link = document.createElement('a');\n  link.href = url;\n  link.download = filename;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n  URL.revokeObjectURL(url);\n};","map":{"version":3,"names":["PDFDocument","rgb","LETTER_WIDTH_INCHES","LETTER_HEIGHT_INCHES","DPI","CARD_WIDTH_INCHES","CARD_HEIGHT_INCHES","POINTS_PER_INCH","PAGE_WIDTH_POINTS","PAGE_HEIGHT_POINTS","CARD_WIDTH_POINTS","CARD_HEIGHT_POINTS","generatePDF","cards","paper","width","height","scale","options","pageWidth","pageHeight","scaleFactor","Math","max","min","Number","cardWidth","cardHeight","scaledMarginX","scaledMarginY","pdfDoc","create","imageBytesArr","Promise","all","map","card","response","fetch","imageUrl","arrayBuffer","Uint8Array","error","console","name","i","length","pageCards","slice","pageImages","page","addPage","blackCorners","CORNER_SIZE","j","row","floor","col","cardX","cardY","drawRectangle","x","y","borderWidth","color","imgBytes","img","embedPng","drawImage","cropMarks","CROP_MARK_LENGTH","CROP_MARK_THICKNESS","isRightmostCard","isBottomCard","cropMarkOffset","rightCropMarkOffset","drawLine","start","end","thickness","rightEdgeX","bottomEdgeY","pdfBytes","save","Blob","type","downloadPDF","pdfBlob","filename","url","URL","createObjectURL","link","document","createElement","href","download","body","appendChild","click","removeChild","revokeObjectURL"],"sources":["C:/MTG/mtg-pdf-printer/mtg-pdf-printer/src/utils/pdfGenerator.js"],"sourcesContent":["import { PDFDocument, rgb } from 'pdf-lib';\n\n// MTGPrint default settings for Letter paper (8.5\" x 11\") at 300 DPI\n// Letter page: 8.5\" x 11\" = 2550 x 3300 pixels at 300 DPI\nconst LETTER_WIDTH_INCHES = 8.5;\nconst LETTER_HEIGHT_INCHES = 11.0;\nconst DPI = 300;\n\n// Standard Magic card dimensions: 2.5\" x 3.5\" = 750 x 1050 pixels at 300 DPI\nconst CARD_WIDTH_INCHES = 2.5;\nconst CARD_HEIGHT_INCHES = 3.5;\n\n// Convert to points (1 inch = 72 points)\nconst POINTS_PER_INCH = 72;\n\n// Page dimensions in points\nconst PAGE_WIDTH_POINTS = LETTER_WIDTH_INCHES * POINTS_PER_INCH;  // 612pt\nconst PAGE_HEIGHT_POINTS = LETTER_HEIGHT_INCHES * POINTS_PER_INCH; // 792pt\n\n// Card dimensions in points\nconst CARD_WIDTH_POINTS = CARD_WIDTH_INCHES * POINTS_PER_INCH;  // 180pt\nconst CARD_HEIGHT_POINTS = CARD_HEIGHT_INCHES * POINTS_PER_INCH; // 252pt\n\n// Calculate margins to center 3x3 grid on Letter page\n// Total grid width: 3 cards * 180pt = 540pt\n// Total grid height: 3 cards * 252pt = 756pt\n// Available space: 612pt x 792pt\n// Margins: (612 - 540) / 2 = 36pt horizontal, (792 - 756) / 2 = 18pt vertical\n\nexport const generatePDF = async (cards, paper = { width: 8.5, height: 11.0 }, scale = 100, options = {}) => {\n  // Use default Letter paper dimensions\n  const pageWidth = PAGE_WIDTH_POINTS;\n  const pageHeight = PAGE_HEIGHT_POINTS;\n\n  // Apply scale factor (90-110% range)\n  const scaleFactor = Math.max(90, Math.min(Number(scale), 110)) / 100;\n  const cardWidth = CARD_WIDTH_POINTS * scaleFactor;\n  const cardHeight = CARD_HEIGHT_POINTS * scaleFactor;\n\n  // Recalculate margins for scaled cards to maintain centering\n  const scaledMarginX = (pageWidth - (3 * cardWidth)) / 2;\n  const scaledMarginY = (pageHeight - (3 * cardHeight)) / 2;\n\n  const pdfDoc = await PDFDocument.create();\n\n  // Pre-fetch all images as Uint8Array\n  const imageBytesArr = await Promise.all(\n    cards.map(async (card) => {\n      try {\n        const response = await fetch(card.imageUrl);\n        const arrayBuffer = await response.arrayBuffer();\n        return new Uint8Array(arrayBuffer);\n      } catch (error) {\n        console.error(`Failed to fetch image for ${card.name}:`, error);\n        return null;\n      }\n    })\n  );\n\n  // Process cards in groups of 9 (3x3 grid per page)\n  for (let i = 0; i < cards.length; i += 9) {\n    const pageCards = cards.slice(i, i + 9);\n    const pageImages = imageBytesArr.slice(i, i + 9);\n    const page = pdfDoc.addPage([pageWidth, pageHeight]);\n\n    // Add black corners if enabled (draw before card images so they appear behind)\n    if (options.blackCorners) {\n      // Black corner dimensions: small squares at each corner (6-8px equivalent)\n      const CORNER_SIZE = 0.0625 * POINTS_PER_INCH; // 4.5pt (~6px at 300 DPI)\n      \n      // Draw black corners for each card on the page\n      for (let j = 0; j < pageCards.length; j++) {\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n        \n        // Calculate card position\n        const cardX = scaledMarginX + (col * cardWidth);\n        const cardY = pageHeight - scaledMarginY - cardHeight - (row * cardHeight);\n        \n        // Draw black corners at each corner of the card\n        // Top-left corner - positioned so inner corner touches card corner\n        page.drawRectangle({\n          x: cardX - CORNER_SIZE,\n          y: cardY + cardHeight,\n          width: CORNER_SIZE,\n          height: CORNER_SIZE,\n          borderWidth: 0,\n          color: rgb(0, 0, 0),\n        });\n        \n        // Top-right corner - positioned so inner corner touches card corner\n        page.drawRectangle({\n          x: cardX + cardWidth,\n          y: cardY + cardHeight,\n          width: CORNER_SIZE,\n          height: CORNER_SIZE,\n          borderWidth: 0,\n          color: rgb(0, 0, 0),\n        });\n        \n        // Bottom-left corner - positioned so inner corner touches card corner\n        page.drawRectangle({\n          x: cardX - CORNER_SIZE,\n          y: cardY - CORNER_SIZE,\n          width: CORNER_SIZE,\n          height: CORNER_SIZE,\n          borderWidth: 0,\n          color: rgb(0, 0, 0),\n        });\n        \n        // Bottom-right corner - positioned so inner corner touches card corner\n        page.drawRectangle({\n          x: cardX + cardWidth,\n          y: cardY - CORNER_SIZE,\n          width: CORNER_SIZE,\n          height: CORNER_SIZE,\n          borderWidth: 0,\n          color: rgb(0, 0, 0),\n        });\n      }\n    }\n\n    // Place cards in 3x3 grid, left-to-right, top-to-bottom\n    for (let j = 0; j < pageCards.length; j++) {\n      const imgBytes = pageImages[j];\n      if (!imgBytes) continue; // Skip if image failed to load\n\n      try {\n        // Embed image (assume PNG)\n        const img = await pdfDoc.embedPng(imgBytes);\n        \n        // Calculate grid position (0-2 for row and column)\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n        \n        // Calculate card position (PDF coordinates: bottom-left origin)\n        const x = scaledMarginX + (col * cardWidth);\n        const y = pageHeight - scaledMarginY - cardHeight - (row * cardHeight);\n        \n        // Draw the card image\n        page.drawImage(img, {\n          x,\n          y,\n          width: cardWidth,\n          height: cardHeight,\n        });\n      } catch (error) {\n        console.error(`Failed to embed image for ${pageCards[j].name}:`, error);\n      }\n    }\n\n    // Add crop marks if enabled\n    if (options.cropMarks) {\n      // Crop mark dimensions: 1/4\" long, 0.5pt wide for thinner marks\n      const CROP_MARK_LENGTH = 0.25 * POINTS_PER_INCH; // 18pt (1/4\")\n      const CROP_MARK_THICKNESS = 0.5; // 0.5pt wide for thinner crop marks\n      \n      // Draw crop marks for each card on the page\n      for (let j = 0; j < pageCards.length; j++) {\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n        \n        // Calculate card position\n        const cardX = scaledMarginX + (col * cardWidth);\n        const cardY = pageHeight - scaledMarginY - cardHeight - (row * cardHeight);\n        \n        // Calculate crop mark offset for outermost edges\n        const isRightmostCard = col === 2; // Rightmost column (0-indexed)\n        const isBottomCard = row === 2; // Bottom row (0-indexed)\n        const cropMarkOffset = CROP_MARK_THICKNESS - 0.75; // Reduced offset (moved back by ~1 pixel)\n        const rightCropMarkOffset = 0.375; // Additional 0.5 pixel offset for right crop marks\n        \n        // Draw crop marks at each corner of the card\n        // Top-left corner (always standard position)\n        page.drawLine({\n          start: { x: cardX - CROP_MARK_LENGTH, y: cardY + cardHeight },\n          end: { x: cardX, y: cardY + cardHeight },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: { x: cardX, y: cardY + cardHeight + CROP_MARK_LENGTH },\n          end: { x: cardX, y: cardY + cardHeight },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        \n        // Top-right corner (offset outward if rightmost card)\n        const rightEdgeX = isRightmostCard ? cardX + cardWidth + cropMarkOffset + rightCropMarkOffset : cardX + cardWidth;\n        page.drawLine({\n          start: { x: rightEdgeX, y: cardY + cardHeight },\n          end: { x: rightEdgeX + CROP_MARK_LENGTH, y: cardY + cardHeight },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: { x: rightEdgeX, y: cardY + cardHeight + CROP_MARK_LENGTH },\n          end: { x: rightEdgeX, y: cardY + cardHeight },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        \n        // Bottom-left corner (offset outward if bottom card)\n        const bottomEdgeY = isBottomCard ? cardY - cropMarkOffset : cardY;\n        page.drawLine({\n          start: { x: cardX - CROP_MARK_LENGTH, y: bottomEdgeY },\n          end: { x: cardX, y: bottomEdgeY },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: { x: cardX, y: bottomEdgeY - CROP_MARK_LENGTH },\n          end: { x: cardX, y: bottomEdgeY },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        \n        // Bottom-right corner (offset outward if rightmost AND bottom card)\n        page.drawLine({\n          start: { x: rightEdgeX, y: bottomEdgeY },\n          end: { x: rightEdgeX + CROP_MARK_LENGTH, y: bottomEdgeY },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: { x: rightEdgeX, y: bottomEdgeY - CROP_MARK_LENGTH },\n          end: { x: rightEdgeX, y: bottomEdgeY },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n      }\n    }\n  }\n\n  const pdfBytes = await pdfDoc.save();\n  return new Blob([pdfBytes], { type: 'application/pdf' });\n};\n\nexport const downloadPDF = (pdfBlob, filename = 'mtg-deck.pdf') => {\n  const url = URL.createObjectURL(pdfBlob);\n  const link = document.createElement('a');\n  link.href = url;\n  link.download = filename;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n  URL.revokeObjectURL(url);\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
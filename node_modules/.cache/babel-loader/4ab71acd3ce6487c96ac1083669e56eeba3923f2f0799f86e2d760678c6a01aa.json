{"ast":null,"code":"import { PDFDocument, rgb } from 'pdf-lib';\n\n// MTGPrint default settings for Letter paper (8.5\" x 11\") at 300 DPI\n// Letter page: 8.5\" x 11\" = 2550 x 3300 pixels at 300 DPI\nconst LETTER_WIDTH_INCHES = 8.5;\nconst LETTER_HEIGHT_INCHES = 11.0;\nconst DPI = 300;\n\n// Standard Magic card dimensions: 2.5\" x 3.5\" = 750 x 1050 pixels at 300 DPI\nconst CARD_WIDTH_INCHES = 2.5;\nconst CARD_HEIGHT_INCHES = 3.5;\n\n// Convert to points (1 inch = 72 points)\nconst POINTS_PER_INCH = 72;\n\n// Page dimensions in points\nconst PAGE_WIDTH_POINTS = LETTER_WIDTH_INCHES * POINTS_PER_INCH; // 612pt\nconst PAGE_HEIGHT_POINTS = LETTER_HEIGHT_INCHES * POINTS_PER_INCH; // 792pt\n\n// Card dimensions in points\nconst CARD_WIDTH_POINTS = CARD_WIDTH_INCHES * POINTS_PER_INCH; // 180pt\nconst CARD_HEIGHT_POINTS = CARD_HEIGHT_INCHES * POINTS_PER_INCH; // 252pt\n\n// Calculate margins to center 3x3 grid on Letter page\n// Total grid width: 3 cards * 180pt = 540pt\n// Total grid height: 3 cards * 252pt = 756pt\n// Available space: 612pt x 792pt\n// Margins: (612 - 540) / 2 = 36pt horizontal, (792 - 756) / 2 = 18pt vertical\n\nexport const generatePDF = async (cards, paper = {\n  width: 8.5,\n  height: 11.0\n}, scale = 100, options = {}) => {\n  // Use default Letter paper dimensions\n  const pageWidth = PAGE_WIDTH_POINTS;\n  const pageHeight = PAGE_HEIGHT_POINTS;\n\n  // Apply scale factor (90-110% range)\n  const scaleFactor = Math.max(90, Math.min(Number(scale), 110)) / 100;\n  const cardWidth = CARD_WIDTH_POINTS * scaleFactor;\n  const cardHeight = CARD_HEIGHT_POINTS * scaleFactor;\n\n  // Recalculate margins for scaled cards to maintain centering\n  const scaledMarginX = (pageWidth - 3 * cardWidth) / 2;\n  const scaledMarginY = (pageHeight - 3 * cardHeight) / 2;\n  const pdfDoc = await PDFDocument.create();\n\n  // Pre-load triangle corner images if black corners are enabled\n  let triangleImages = null;\n  if (options.blackCorners) {\n    try {\n      const triangleUrls = ['/triangle_topleft.png', '/triangle_topright.png', '/triangle_bottomleft.png', '/triangle_bottomright.png'];\n      triangleImages = await Promise.all(triangleUrls.map(async url => {\n        const response = await fetch(url);\n        const arrayBuffer = await response.arrayBuffer();\n        return await pdfDoc.embedPng(new Uint8Array(arrayBuffer));\n      }));\n    } catch (error) {\n      console.error('Failed to load triangle images:', error);\n      triangleImages = null;\n    }\n  }\n\n  // Pre-fetch all images as Uint8Array\n  const imageBytesArr = await Promise.all(cards.map(async card => {\n    try {\n      const response = await fetch(card.imageUrl);\n      const arrayBuffer = await response.arrayBuffer();\n      return new Uint8Array(arrayBuffer);\n    } catch (error) {\n      console.error(`Failed to fetch image for ${card.name}:`, error);\n      return null;\n    }\n  }));\n\n  // Process cards in groups of 9 (3x3 grid per page)\n  for (let i = 0; i < cards.length; i += 9) {\n    const pageCards = cards.slice(i, i + 9);\n    const pageImages = imageBytesArr.slice(i, i + 9);\n    const page = pdfDoc.addPage([pageWidth, pageHeight]);\n\n    // Place cards in 3x3 grid, left-to-right, top-to-bottom\n    for (let j = 0; j < pageCards.length; j++) {\n      const imgBytes = pageImages[j];\n      if (!imgBytes) continue; // Skip if image failed to load\n\n      try {\n        // Embed image (assume PNG)\n        const img = await pdfDoc.embedPng(imgBytes);\n\n        // Calculate grid position (0-2 for row and column)\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n\n        // Calculate card position (PDF coordinates: bottom-left origin)\n        const x = scaledMarginX + col * cardWidth;\n        const y = pageHeight - scaledMarginY - cardHeight - row * cardHeight;\n\n        // Draw the card image\n        page.drawImage(img, {\n          x,\n          y,\n          width: cardWidth,\n          height: cardHeight\n        });\n      } catch (error) {\n        console.error(`Failed to embed image for ${pageCards[j].name}:`, error);\n      }\n    }\n\n    // Draw black corner triangles above the cards if enabled\n    if (options.blackCorners && triangleImages) {\n      const TRIANGLE_SIZE = 32; // 8px triangle size\n      const TRIANGLE_SIZE_POINTS = TRIANGLE_SIZE * (POINTS_PER_INCH / 300); // Convert to points\n\n      for (let j = 0; j < pageCards.length; j++) {\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n\n        // Calculate card position\n        const cardX = scaledMarginX + col * cardWidth;\n        const cardY = pageHeight - scaledMarginY - cardHeight - row * cardHeight;\n\n        // Draw triangle corners at each corner of the card\n        // Top-left corner\n        page.drawImage(triangleImages[0], {\n          x: cardX,\n          y: cardY + cardHeight - TRIANGLE_SIZE_POINTS,\n          width: TRIANGLE_SIZE_POINTS,\n          height: TRIANGLE_SIZE_POINTS\n        });\n\n        // Top-right corner\n        page.drawImage(triangleImages[1], {\n          x: cardX + cardWidth - TRIANGLE_SIZE_POINTS + 0.24,\n          y: cardY + cardHeight - TRIANGLE_SIZE_POINTS,\n          width: TRIANGLE_SIZE_POINTS,\n          height: TRIANGLE_SIZE_POINTS\n        });\n\n        // Bottom-left corner\n        page.drawImage(triangleImages[2], {\n          x: cardX,\n          y: cardY,\n          width: TRIANGLE_SIZE_POINTS,\n          height: TRIANGLE_SIZE_POINTS\n        });\n\n        // Bottom-right corner\n        page.drawImage(triangleImages[3], {\n          x: cardX + cardWidth - TRIANGLE_SIZE_POINTS + 0.24,\n          y: cardY,\n          width: TRIANGLE_SIZE_POINTS,\n          height: TRIANGLE_SIZE_POINTS\n        });\n      }\n    }\n\n    // Add crop marks if enabled\n    if (options.cropMarks) {\n      // Crop mark dimensions: 1/4\" long, 0.5pt wide for thinner marks\n      const CROP_MARK_LENGTH = 0.25 * POINTS_PER_INCH; // 18pt (1/4\")\n      const CROP_MARK_THICKNESS = 0.5; // 0.5pt wide for thinner crop marks\n\n      // Draw crop marks for each card on the page\n      for (let j = 0; j < pageCards.length; j++) {\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n\n        // Calculate card position\n        const cardX = scaledMarginX + col * cardWidth;\n        const cardY = pageHeight - scaledMarginY - cardHeight - row * cardHeight;\n\n        // Calculate crop mark offset for outermost edges\n        const isRightmostCard = col === 2; // Rightmost column (0-indexed)\n        const isBottomCard = row === 2; // Bottom row (0-indexed)\n        const cropMarkOffset = CROP_MARK_THICKNESS - 0.75; // Reduced offset (moved back by ~1 pixel)\n        const rightCropMarkOffset = 0.375; // Additional 0.5 pixel offset for right crop marks\n\n        // Draw crop marks at each corner of the card\n        // Top-left corner (always standard position)\n        page.drawLine({\n          start: {\n            x: cardX - CROP_MARK_LENGTH,\n            y: cardY + cardHeight\n          },\n          end: {\n            x: cardX,\n            y: cardY + cardHeight\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: {\n            x: cardX,\n            y: cardY + cardHeight + CROP_MARK_LENGTH\n          },\n          end: {\n            x: cardX,\n            y: cardY + cardHeight\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n\n        // Top-right corner (offset outward if rightmost card)\n        const rightEdgeX = isRightmostCard ? cardX + cardWidth + cropMarkOffset + rightCropMarkOffset : cardX + cardWidth;\n        page.drawLine({\n          start: {\n            x: rightEdgeX,\n            y: cardY + cardHeight\n          },\n          end: {\n            x: rightEdgeX + CROP_MARK_LENGTH,\n            y: cardY + cardHeight\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: {\n            x: rightEdgeX,\n            y: cardY + cardHeight + CROP_MARK_LENGTH\n          },\n          end: {\n            x: rightEdgeX,\n            y: cardY + cardHeight\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n\n        // Bottom-left corner (offset outward if bottom card)\n        const bottomEdgeY = isBottomCard ? cardY - cropMarkOffset : cardY;\n        page.drawLine({\n          start: {\n            x: cardX - CROP_MARK_LENGTH,\n            y: bottomEdgeY\n          },\n          end: {\n            x: cardX,\n            y: bottomEdgeY\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: {\n            x: cardX,\n            y: bottomEdgeY - CROP_MARK_LENGTH\n          },\n          end: {\n            x: cardX,\n            y: bottomEdgeY\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n\n        // Bottom-right corner (offset outward if rightmost AND bottom card)\n        page.drawLine({\n          start: {\n            x: rightEdgeX,\n            y: bottomEdgeY\n          },\n          end: {\n            x: rightEdgeX + CROP_MARK_LENGTH,\n            y: bottomEdgeY\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: {\n            x: rightEdgeX,\n            y: bottomEdgeY - CROP_MARK_LENGTH\n          },\n          end: {\n            x: rightEdgeX,\n            y: bottomEdgeY\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n      }\n    }\n  }\n  const pdfBytes = await pdfDoc.save();\n  return new Blob([pdfBytes], {\n    type: 'application/pdf'\n  });\n};\nexport const downloadPDF = (pdfBlob, filename = 'mtg-deck.pdf') => {\n  const url = URL.createObjectURL(pdfBlob);\n  const link = document.createElement('a');\n  link.href = url;\n  link.download = filename;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n  URL.revokeObjectURL(url);\n};","map":{"version":3,"names":["PDFDocument","rgb","LETTER_WIDTH_INCHES","LETTER_HEIGHT_INCHES","DPI","CARD_WIDTH_INCHES","CARD_HEIGHT_INCHES","POINTS_PER_INCH","PAGE_WIDTH_POINTS","PAGE_HEIGHT_POINTS","CARD_WIDTH_POINTS","CARD_HEIGHT_POINTS","generatePDF","cards","paper","width","height","scale","options","pageWidth","pageHeight","scaleFactor","Math","max","min","Number","cardWidth","cardHeight","scaledMarginX","scaledMarginY","pdfDoc","create","triangleImages","blackCorners","triangleUrls","Promise","all","map","url","response","fetch","arrayBuffer","embedPng","Uint8Array","error","console","imageBytesArr","card","imageUrl","name","i","length","pageCards","slice","pageImages","page","addPage","j","imgBytes","img","row","floor","col","x","y","drawImage","TRIANGLE_SIZE","TRIANGLE_SIZE_POINTS","cardX","cardY","cropMarks","CROP_MARK_LENGTH","CROP_MARK_THICKNESS","isRightmostCard","isBottomCard","cropMarkOffset","rightCropMarkOffset","drawLine","start","end","thickness","color","rightEdgeX","bottomEdgeY","pdfBytes","save","Blob","type","downloadPDF","pdfBlob","filename","URL","createObjectURL","link","document","createElement","href","download","body","appendChild","click","removeChild","revokeObjectURL"],"sources":["C:/MTG/mtg-pdf-printer/mtg-pdf-printer/src/utils/pdfGenerator.js"],"sourcesContent":["import { PDFDocument, rgb } from 'pdf-lib';\n\n// MTGPrint default settings for Letter paper (8.5\" x 11\") at 300 DPI\n// Letter page: 8.5\" x 11\" = 2550 x 3300 pixels at 300 DPI\nconst LETTER_WIDTH_INCHES = 8.5;\nconst LETTER_HEIGHT_INCHES = 11.0;\nconst DPI = 300;\n\n// Standard Magic card dimensions: 2.5\" x 3.5\" = 750 x 1050 pixels at 300 DPI\nconst CARD_WIDTH_INCHES = 2.5;\nconst CARD_HEIGHT_INCHES = 3.5;\n\n// Convert to points (1 inch = 72 points)\nconst POINTS_PER_INCH = 72;\n\n// Page dimensions in points\nconst PAGE_WIDTH_POINTS = LETTER_WIDTH_INCHES * POINTS_PER_INCH;  // 612pt\nconst PAGE_HEIGHT_POINTS = LETTER_HEIGHT_INCHES * POINTS_PER_INCH; // 792pt\n\n// Card dimensions in points\nconst CARD_WIDTH_POINTS = CARD_WIDTH_INCHES * POINTS_PER_INCH;  // 180pt\nconst CARD_HEIGHT_POINTS = CARD_HEIGHT_INCHES * POINTS_PER_INCH; // 252pt\n\n// Calculate margins to center 3x3 grid on Letter page\n// Total grid width: 3 cards * 180pt = 540pt\n// Total grid height: 3 cards * 252pt = 756pt\n// Available space: 612pt x 792pt\n// Margins: (612 - 540) / 2 = 36pt horizontal, (792 - 756) / 2 = 18pt vertical\n\nexport const generatePDF = async (cards, paper = { width: 8.5, height: 11.0 }, scale = 100, options = {}) => {\n  // Use default Letter paper dimensions\n  const pageWidth = PAGE_WIDTH_POINTS;\n  const pageHeight = PAGE_HEIGHT_POINTS;\n\n  // Apply scale factor (90-110% range)\n  const scaleFactor = Math.max(90, Math.min(Number(scale), 110)) / 100;\n  const cardWidth = CARD_WIDTH_POINTS * scaleFactor;\n  const cardHeight = CARD_HEIGHT_POINTS * scaleFactor;\n\n  // Recalculate margins for scaled cards to maintain centering\n  const scaledMarginX = (pageWidth - (3 * cardWidth)) / 2;\n  const scaledMarginY = (pageHeight - (3 * cardHeight)) / 2;\n\n  const pdfDoc = await PDFDocument.create();\n\n  // Pre-load triangle corner images if black corners are enabled\n  let triangleImages = null;\n  if (options.blackCorners) {\n    try {\n      const triangleUrls = [\n        '/triangle_topleft.png',\n        '/triangle_topright.png',\n        '/triangle_bottomleft.png',\n        '/triangle_bottomright.png'\n      ];\n      \n      triangleImages = await Promise.all(\n        triangleUrls.map(async (url) => {\n          const response = await fetch(url);\n          const arrayBuffer = await response.arrayBuffer();\n          return await pdfDoc.embedPng(new Uint8Array(arrayBuffer));\n        })\n      );\n    } catch (error) {\n      console.error('Failed to load triangle images:', error);\n      triangleImages = null;\n    }\n  }\n\n  // Pre-fetch all images as Uint8Array\n  const imageBytesArr = await Promise.all(\n    cards.map(async (card) => {\n      try {\n        const response = await fetch(card.imageUrl);\n        const arrayBuffer = await response.arrayBuffer();\n        return new Uint8Array(arrayBuffer);\n      } catch (error) {\n        console.error(`Failed to fetch image for ${card.name}:`, error);\n        return null;\n      }\n    })\n  );\n\n  // Process cards in groups of 9 (3x3 grid per page)\n  for (let i = 0; i < cards.length; i += 9) {\n    const pageCards = cards.slice(i, i + 9);\n    const pageImages = imageBytesArr.slice(i, i + 9);\n    const page = pdfDoc.addPage([pageWidth, pageHeight]);\n\n    // Place cards in 3x3 grid, left-to-right, top-to-bottom\n    for (let j = 0; j < pageCards.length; j++) {\n      const imgBytes = pageImages[j];\n      if (!imgBytes) continue; // Skip if image failed to load\n\n      try {\n        // Embed image (assume PNG)\n        const img = await pdfDoc.embedPng(imgBytes);\n        \n        // Calculate grid position (0-2 for row and column)\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n        \n        // Calculate card position (PDF coordinates: bottom-left origin)\n        const x = scaledMarginX + (col * cardWidth);\n        const y = pageHeight - scaledMarginY - cardHeight - (row * cardHeight);\n        \n        // Draw the card image\n        page.drawImage(img, {\n          x,\n          y,\n          width: cardWidth,\n          height: cardHeight,\n        });\n      } catch (error) {\n        console.error(`Failed to embed image for ${pageCards[j].name}:`, error);\n      }\n    }\n\n    // Draw black corner triangles above the cards if enabled\n    if (options.blackCorners && triangleImages) {\n      const TRIANGLE_SIZE = 32; // 8px triangle size\n      const TRIANGLE_SIZE_POINTS = TRIANGLE_SIZE * (POINTS_PER_INCH / 300); // Convert to points\n      \n      for (let j = 0; j < pageCards.length; j++) {\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n        \n        // Calculate card position\n        const cardX = scaledMarginX + (col * cardWidth);\n        const cardY = pageHeight - scaledMarginY - cardHeight - (row * cardHeight);\n        \n        // Draw triangle corners at each corner of the card\n        // Top-left corner\n        page.drawImage(triangleImages[0], {\n          x: cardX,\n          y: cardY + cardHeight - TRIANGLE_SIZE_POINTS,\n          width: TRIANGLE_SIZE_POINTS,\n          height: TRIANGLE_SIZE_POINTS,\n        });\n        \n        // Top-right corner\n        page.drawImage(triangleImages[1], {\n          x: cardX + cardWidth - TRIANGLE_SIZE_POINTS + 0.24,\n          y: cardY + cardHeight - TRIANGLE_SIZE_POINTS,\n          width: TRIANGLE_SIZE_POINTS,\n          height: TRIANGLE_SIZE_POINTS,\n        });\n        \n        // Bottom-left corner\n        page.drawImage(triangleImages[2], {\n          x: cardX,\n          y: cardY,\n          width: TRIANGLE_SIZE_POINTS,\n          height: TRIANGLE_SIZE_POINTS,\n        });\n        \n        // Bottom-right corner\n        page.drawImage(triangleImages[3], {\n          x: cardX + cardWidth - TRIANGLE_SIZE_POINTS + 0.24,\n          y: cardY,\n          width: TRIANGLE_SIZE_POINTS,\n          height: TRIANGLE_SIZE_POINTS,\n        });\n      }\n    }\n\n\n\n    // Add crop marks if enabled\n    if (options.cropMarks) {\n      // Crop mark dimensions: 1/4\" long, 0.5pt wide for thinner marks\n      const CROP_MARK_LENGTH = 0.25 * POINTS_PER_INCH; // 18pt (1/4\")\n      const CROP_MARK_THICKNESS = 0.5; // 0.5pt wide for thinner crop marks\n      \n      // Draw crop marks for each card on the page\n      for (let j = 0; j < pageCards.length; j++) {\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n        \n        // Calculate card position\n        const cardX = scaledMarginX + (col * cardWidth);\n        const cardY = pageHeight - scaledMarginY - cardHeight - (row * cardHeight);\n        \n        // Calculate crop mark offset for outermost edges\n        const isRightmostCard = col === 2; // Rightmost column (0-indexed)\n        const isBottomCard = row === 2; // Bottom row (0-indexed)\n        const cropMarkOffset = CROP_MARK_THICKNESS - 0.75; // Reduced offset (moved back by ~1 pixel)\n        const rightCropMarkOffset = 0.375; // Additional 0.5 pixel offset for right crop marks\n        \n        // Draw crop marks at each corner of the card\n        // Top-left corner (always standard position)\n        page.drawLine({\n          start: { x: cardX - CROP_MARK_LENGTH, y: cardY + cardHeight },\n          end: { x: cardX, y: cardY + cardHeight },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: { x: cardX, y: cardY + cardHeight + CROP_MARK_LENGTH },\n          end: { x: cardX, y: cardY + cardHeight },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        \n        // Top-right corner (offset outward if rightmost card)\n        const rightEdgeX = isRightmostCard ? cardX + cardWidth + cropMarkOffset + rightCropMarkOffset : cardX + cardWidth;\n        page.drawLine({\n          start: { x: rightEdgeX, y: cardY + cardHeight },\n          end: { x: rightEdgeX + CROP_MARK_LENGTH, y: cardY + cardHeight },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: { x: rightEdgeX, y: cardY + cardHeight + CROP_MARK_LENGTH },\n          end: { x: rightEdgeX, y: cardY + cardHeight },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        \n        // Bottom-left corner (offset outward if bottom card)\n        const bottomEdgeY = isBottomCard ? cardY - cropMarkOffset : cardY;\n        page.drawLine({\n          start: { x: cardX - CROP_MARK_LENGTH, y: bottomEdgeY },\n          end: { x: cardX, y: bottomEdgeY },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: { x: cardX, y: bottomEdgeY - CROP_MARK_LENGTH },\n          end: { x: cardX, y: bottomEdgeY },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        \n        // Bottom-right corner (offset outward if rightmost AND bottom card)\n        page.drawLine({\n          start: { x: rightEdgeX, y: bottomEdgeY },\n          end: { x: rightEdgeX + CROP_MARK_LENGTH, y: bottomEdgeY },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: { x: rightEdgeX, y: bottomEdgeY - CROP_MARK_LENGTH },\n          end: { x: rightEdgeX, y: bottomEdgeY },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n      }\n    }\n  }\n\n  const pdfBytes = await pdfDoc.save();\n  return new Blob([pdfBytes], { type: 'application/pdf' });\n};\n\nexport const downloadPDF = (pdfBlob, filename = 'mtg-deck.pdf') => {\n  const url = URL.createObjectURL(pdfBlob);\n  const link = document.createElement('a');\n  link.href = url;\n  link.download = filename;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n  URL.revokeObjectURL(url);\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
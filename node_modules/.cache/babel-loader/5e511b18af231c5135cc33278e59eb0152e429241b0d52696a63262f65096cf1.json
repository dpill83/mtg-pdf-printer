{"ast":null,"code":"import { PDFDocument, rgb } from 'pdf-lib';\n\n// MTGPrint default settings for Letter paper (8.5\" x 11\") at 300 DPI\n// Letter page: 8.5\" x 11\" = 2550 x 3300 pixels at 300 DPI\nconst LETTER_WIDTH_INCHES = 8.5;\nconst LETTER_HEIGHT_INCHES = 11.0;\nconst DPI = 300;\n\n// Standard Magic card dimensions: 2.5\" x 3.5\" = 750 x 1050 pixels at 300 DPI\nconst CARD_WIDTH_INCHES = 2.5;\nconst CARD_HEIGHT_INCHES = 3.5;\n\n// Convert to points (1 inch = 72 points)\nconst POINTS_PER_INCH = 72;\n\n// Page dimensions in points\nconst PAGE_WIDTH_POINTS = LETTER_WIDTH_INCHES * POINTS_PER_INCH; // 612pt\nconst PAGE_HEIGHT_POINTS = LETTER_HEIGHT_INCHES * POINTS_PER_INCH; // 792pt\n\n// Card dimensions in points\nconst CARD_WIDTH_POINTS = CARD_WIDTH_INCHES * POINTS_PER_INCH; // 180pt\nconst CARD_HEIGHT_POINTS = CARD_HEIGHT_INCHES * POINTS_PER_INCH; // 252pt\n\n// Calculate margins to center 3x3 grid on Letter page\n// Total grid width: 3 cards * 180pt = 540pt\n// Total grid height: 3 cards * 252pt = 756pt\n// Available space: 612pt x 792pt\n// Margins: (612 - 540) / 2 = 36pt horizontal, (792 - 756) / 2 = 18pt vertical\n\nexport const generatePDF = async (cards, paper = {\n  width: 8.5,\n  height: 11.0\n}, scale = 100, options = {}) => {\n  // Use default Letter paper dimensions\n  const pageWidth = PAGE_WIDTH_POINTS;\n  const pageHeight = PAGE_HEIGHT_POINTS;\n\n  // Apply scale factor (90-110% range)\n  const scaleFactor = Math.max(90, Math.min(Number(scale), 110)) / 100;\n  const cardWidth = CARD_WIDTH_POINTS * scaleFactor;\n  const cardHeight = CARD_HEIGHT_POINTS * scaleFactor;\n\n  // Recalculate margins for scaled cards to maintain centering\n  const scaledMarginX = (pageWidth - 3 * cardWidth) / 2;\n  const scaledMarginY = (pageHeight - 3 * cardHeight) / 2;\n  const pdfDoc = await PDFDocument.create();\n\n  // Pre-fetch all images as Uint8Array\n  const imageBytesArr = await Promise.all(cards.map(async card => {\n    try {\n      const response = await fetch(card.imageUrl);\n      const arrayBuffer = await response.arrayBuffer();\n      return new Uint8Array(arrayBuffer);\n    } catch (error) {\n      console.error(`Failed to fetch image for ${card.name}:`, error);\n      return null;\n    }\n  }));\n\n  // Process cards in groups of 9 (3x3 grid per page)\n  for (let i = 0; i < cards.length; i += 9) {\n    const pageCards = cards.slice(i, i + 9);\n    const pageImages = imageBytesArr.slice(i, i + 9);\n    const page = pdfDoc.addPage([pageWidth, pageHeight]);\n\n    // Place cards in 3x3 grid, left-to-right, top-to-bottom\n    for (let j = 0; j < pageCards.length; j++) {\n      const imgBytes = pageImages[j];\n      if (!imgBytes) continue; // Skip if image failed to load\n\n      try {\n        // Embed image (assume PNG)\n        const img = await pdfDoc.embedPng(imgBytes);\n\n        // Calculate grid position (0-2 for row and column)\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n\n        // Calculate card position (PDF coordinates: bottom-left origin)\n        const x = scaledMarginX + col * cardWidth;\n        const y = pageHeight - scaledMarginY - cardHeight - row * cardHeight;\n\n        // Draw the card image\n        page.drawImage(img, {\n          x,\n          y,\n          width: cardWidth,\n          height: cardHeight\n        });\n      } catch (error) {\n        console.error(`Failed to embed image for ${pageCards[j].name}:`, error);\n      }\n    }\n\n    // Add black corners if enabled\n    if (options.blackCorners) {\n      // Black corner dimensions: 8pt right triangles\n      const SIZE = 8; // 8pt triangle size\n\n      // Draw black corners for each card on the page\n      for (let j = 0; j < pageCards.length; j++) {\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n\n        // Calculate card position\n        const cardX = scaledMarginX + col * cardWidth;\n        const cardY = pageHeight - scaledMarginY - cardHeight - row * cardHeight;\n\n        // Draw black corner triangles at each corner of the card\n        // Top-left corner: right angle points into the corner\n        page.drawPath(`M ${cardX - SIZE} ${cardY + cardHeight} L ${cardX} ${cardY + cardHeight} L ${cardX} ${cardY + cardHeight + SIZE} Z`, {\n          color: rgb(0, 0, 0)\n        });\n\n        // Top-right corner: right angle points into the corner\n        page.drawPath(`M ${cardX + cardWidth} ${cardY + cardHeight} L ${cardX + cardWidth + SIZE} ${cardY + cardHeight} L ${cardX + cardWidth} ${cardY + cardHeight + SIZE} Z`, {\n          color: rgb(0, 0, 0)\n        });\n\n        // Bottom-left corner: right angle points into the corner\n        page.drawPath(`M ${cardX - SIZE} ${cardY} L ${cardX} ${cardY} L ${cardX} ${cardY - SIZE} Z`, {\n          color: rgb(0, 0, 0)\n        });\n\n        // Bottom-right corner: right angle points into the corner\n        page.drawPath(`M ${cardX + cardWidth} ${cardY} L ${cardX + cardWidth + SIZE} ${cardY} L ${cardX + cardWidth} ${cardY - SIZE} Z`, {\n          color: rgb(0, 0, 0)\n        });\n      }\n    }\n\n    // Add crop marks if enabled\n    if (options.cropMarks) {\n      // Crop mark dimensions: 1/4\" long, 0.5pt wide for thinner marks\n      const CROP_MARK_LENGTH = 0.25 * POINTS_PER_INCH; // 18pt (1/4\")\n      const CROP_MARK_THICKNESS = 0.5; // 0.5pt wide for thinner crop marks\n\n      // Draw crop marks for each card on the page\n      for (let j = 0; j < pageCards.length; j++) {\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n\n        // Calculate card position\n        const cardX = scaledMarginX + col * cardWidth;\n        const cardY = pageHeight - scaledMarginY - cardHeight - row * cardHeight;\n\n        // Calculate crop mark offset for outermost edges\n        const isRightmostCard = col === 2; // Rightmost column (0-indexed)\n        const isBottomCard = row === 2; // Bottom row (0-indexed)\n        const cropMarkOffset = CROP_MARK_THICKNESS - 0.75; // Reduced offset (moved back by ~1 pixel)\n        const rightCropMarkOffset = 0.375; // Additional 0.5 pixel offset for right crop marks\n\n        // Draw crop marks at each corner of the card\n        // Top-left corner (always standard position)\n        page.drawLine({\n          start: {\n            x: cardX - CROP_MARK_LENGTH,\n            y: cardY + cardHeight\n          },\n          end: {\n            x: cardX,\n            y: cardY + cardHeight\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: {\n            x: cardX,\n            y: cardY + cardHeight + CROP_MARK_LENGTH\n          },\n          end: {\n            x: cardX,\n            y: cardY + cardHeight\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n\n        // Top-right corner (offset outward if rightmost card)\n        const rightEdgeX = isRightmostCard ? cardX + cardWidth + cropMarkOffset + rightCropMarkOffset : cardX + cardWidth;\n        page.drawLine({\n          start: {\n            x: rightEdgeX,\n            y: cardY + cardHeight\n          },\n          end: {\n            x: rightEdgeX + CROP_MARK_LENGTH,\n            y: cardY + cardHeight\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: {\n            x: rightEdgeX,\n            y: cardY + cardHeight + CROP_MARK_LENGTH\n          },\n          end: {\n            x: rightEdgeX,\n            y: cardY + cardHeight\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n\n        // Bottom-left corner (offset outward if bottom card)\n        const bottomEdgeY = isBottomCard ? cardY - cropMarkOffset : cardY;\n        page.drawLine({\n          start: {\n            x: cardX - CROP_MARK_LENGTH,\n            y: bottomEdgeY\n          },\n          end: {\n            x: cardX,\n            y: bottomEdgeY\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: {\n            x: cardX,\n            y: bottomEdgeY - CROP_MARK_LENGTH\n          },\n          end: {\n            x: cardX,\n            y: bottomEdgeY\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n\n        // Bottom-right corner (offset outward if rightmost AND bottom card)\n        page.drawLine({\n          start: {\n            x: rightEdgeX,\n            y: bottomEdgeY\n          },\n          end: {\n            x: rightEdgeX + CROP_MARK_LENGTH,\n            y: bottomEdgeY\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: {\n            x: rightEdgeX,\n            y: bottomEdgeY - CROP_MARK_LENGTH\n          },\n          end: {\n            x: rightEdgeX,\n            y: bottomEdgeY\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n      }\n    }\n  }\n  const pdfBytes = await pdfDoc.save();\n  return new Blob([pdfBytes], {\n    type: 'application/pdf'\n  });\n};\nexport const downloadPDF = (pdfBlob, filename = 'mtg-deck.pdf') => {\n  const url = URL.createObjectURL(pdfBlob);\n  const link = document.createElement('a');\n  link.href = url;\n  link.download = filename;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n  URL.revokeObjectURL(url);\n};","map":{"version":3,"names":["PDFDocument","rgb","LETTER_WIDTH_INCHES","LETTER_HEIGHT_INCHES","DPI","CARD_WIDTH_INCHES","CARD_HEIGHT_INCHES","POINTS_PER_INCH","PAGE_WIDTH_POINTS","PAGE_HEIGHT_POINTS","CARD_WIDTH_POINTS","CARD_HEIGHT_POINTS","generatePDF","cards","paper","width","height","scale","options","pageWidth","pageHeight","scaleFactor","Math","max","min","Number","cardWidth","cardHeight","scaledMarginX","scaledMarginY","pdfDoc","create","imageBytesArr","Promise","all","map","card","response","fetch","imageUrl","arrayBuffer","Uint8Array","error","console","name","i","length","pageCards","slice","pageImages","page","addPage","j","imgBytes","img","embedPng","row","floor","col","x","y","drawImage","blackCorners","SIZE","cardX","cardY","drawPath","color","cropMarks","CROP_MARK_LENGTH","CROP_MARK_THICKNESS","isRightmostCard","isBottomCard","cropMarkOffset","rightCropMarkOffset","drawLine","start","end","thickness","rightEdgeX","bottomEdgeY","pdfBytes","save","Blob","type","downloadPDF","pdfBlob","filename","url","URL","createObjectURL","link","document","createElement","href","download","body","appendChild","click","removeChild","revokeObjectURL"],"sources":["C:/MTG/mtg-pdf-printer/mtg-pdf-printer/src/utils/pdfGenerator.js"],"sourcesContent":["import { PDFDocument, rgb } from 'pdf-lib';\n\n// MTGPrint default settings for Letter paper (8.5\" x 11\") at 300 DPI\n// Letter page: 8.5\" x 11\" = 2550 x 3300 pixels at 300 DPI\nconst LETTER_WIDTH_INCHES = 8.5;\nconst LETTER_HEIGHT_INCHES = 11.0;\nconst DPI = 300;\n\n// Standard Magic card dimensions: 2.5\" x 3.5\" = 750 x 1050 pixels at 300 DPI\nconst CARD_WIDTH_INCHES = 2.5;\nconst CARD_HEIGHT_INCHES = 3.5;\n\n// Convert to points (1 inch = 72 points)\nconst POINTS_PER_INCH = 72;\n\n// Page dimensions in points\nconst PAGE_WIDTH_POINTS = LETTER_WIDTH_INCHES * POINTS_PER_INCH;  // 612pt\nconst PAGE_HEIGHT_POINTS = LETTER_HEIGHT_INCHES * POINTS_PER_INCH; // 792pt\n\n// Card dimensions in points\nconst CARD_WIDTH_POINTS = CARD_WIDTH_INCHES * POINTS_PER_INCH;  // 180pt\nconst CARD_HEIGHT_POINTS = CARD_HEIGHT_INCHES * POINTS_PER_INCH; // 252pt\n\n// Calculate margins to center 3x3 grid on Letter page\n// Total grid width: 3 cards * 180pt = 540pt\n// Total grid height: 3 cards * 252pt = 756pt\n// Available space: 612pt x 792pt\n// Margins: (612 - 540) / 2 = 36pt horizontal, (792 - 756) / 2 = 18pt vertical\n\nexport const generatePDF = async (cards, paper = { width: 8.5, height: 11.0 }, scale = 100, options = {}) => {\n  // Use default Letter paper dimensions\n  const pageWidth = PAGE_WIDTH_POINTS;\n  const pageHeight = PAGE_HEIGHT_POINTS;\n\n  // Apply scale factor (90-110% range)\n  const scaleFactor = Math.max(90, Math.min(Number(scale), 110)) / 100;\n  const cardWidth = CARD_WIDTH_POINTS * scaleFactor;\n  const cardHeight = CARD_HEIGHT_POINTS * scaleFactor;\n\n  // Recalculate margins for scaled cards to maintain centering\n  const scaledMarginX = (pageWidth - (3 * cardWidth)) / 2;\n  const scaledMarginY = (pageHeight - (3 * cardHeight)) / 2;\n\n  const pdfDoc = await PDFDocument.create();\n\n  // Pre-fetch all images as Uint8Array\n  const imageBytesArr = await Promise.all(\n    cards.map(async (card) => {\n      try {\n        const response = await fetch(card.imageUrl);\n        const arrayBuffer = await response.arrayBuffer();\n        return new Uint8Array(arrayBuffer);\n      } catch (error) {\n        console.error(`Failed to fetch image for ${card.name}:`, error);\n        return null;\n      }\n    })\n  );\n\n  // Process cards in groups of 9 (3x3 grid per page)\n  for (let i = 0; i < cards.length; i += 9) {\n    const pageCards = cards.slice(i, i + 9);\n    const pageImages = imageBytesArr.slice(i, i + 9);\n    const page = pdfDoc.addPage([pageWidth, pageHeight]);\n\n    // Place cards in 3x3 grid, left-to-right, top-to-bottom\n    for (let j = 0; j < pageCards.length; j++) {\n      const imgBytes = pageImages[j];\n      if (!imgBytes) continue; // Skip if image failed to load\n\n      try {\n        // Embed image (assume PNG)\n        const img = await pdfDoc.embedPng(imgBytes);\n        \n        // Calculate grid position (0-2 for row and column)\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n        \n        // Calculate card position (PDF coordinates: bottom-left origin)\n        const x = scaledMarginX + (col * cardWidth);\n        const y = pageHeight - scaledMarginY - cardHeight - (row * cardHeight);\n        \n        // Draw the card image\n        page.drawImage(img, {\n          x,\n          y,\n          width: cardWidth,\n          height: cardHeight,\n        });\n      } catch (error) {\n        console.error(`Failed to embed image for ${pageCards[j].name}:`, error);\n      }\n    }\n\n    // Add black corners if enabled\n    if (options.blackCorners) {\n      // Black corner dimensions: 8pt right triangles\n      const SIZE = 8; // 8pt triangle size\n      \n      // Draw black corners for each card on the page\n      for (let j = 0; j < pageCards.length; j++) {\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n        \n        // Calculate card position\n        const cardX = scaledMarginX + (col * cardWidth);\n        const cardY = pageHeight - scaledMarginY - cardHeight - (row * cardHeight);\n        \n        // Draw black corner triangles at each corner of the card\n        // Top-left corner: right angle points into the corner\n        page.drawPath(`M ${cardX - SIZE} ${cardY + cardHeight} L ${cardX} ${cardY + cardHeight} L ${cardX} ${cardY + cardHeight + SIZE} Z`, {\n          color: rgb(0, 0, 0),\n        });\n        \n        // Top-right corner: right angle points into the corner\n        page.drawPath(`M ${cardX + cardWidth} ${cardY + cardHeight} L ${cardX + cardWidth + SIZE} ${cardY + cardHeight} L ${cardX + cardWidth} ${cardY + cardHeight + SIZE} Z`, {\n          color: rgb(0, 0, 0),\n        });\n        \n        // Bottom-left corner: right angle points into the corner\n        page.drawPath(`M ${cardX - SIZE} ${cardY} L ${cardX} ${cardY} L ${cardX} ${cardY - SIZE} Z`, {\n          color: rgb(0, 0, 0),\n        });\n        \n        // Bottom-right corner: right angle points into the corner\n        page.drawPath(`M ${cardX + cardWidth} ${cardY} L ${cardX + cardWidth + SIZE} ${cardY} L ${cardX + cardWidth} ${cardY - SIZE} Z`, {\n          color: rgb(0, 0, 0),\n        });\n      }\n    }\n\n    // Add crop marks if enabled\n    if (options.cropMarks) {\n      // Crop mark dimensions: 1/4\" long, 0.5pt wide for thinner marks\n      const CROP_MARK_LENGTH = 0.25 * POINTS_PER_INCH; // 18pt (1/4\")\n      const CROP_MARK_THICKNESS = 0.5; // 0.5pt wide for thinner crop marks\n      \n      // Draw crop marks for each card on the page\n      for (let j = 0; j < pageCards.length; j++) {\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n        \n        // Calculate card position\n        const cardX = scaledMarginX + (col * cardWidth);\n        const cardY = pageHeight - scaledMarginY - cardHeight - (row * cardHeight);\n        \n        // Calculate crop mark offset for outermost edges\n        const isRightmostCard = col === 2; // Rightmost column (0-indexed)\n        const isBottomCard = row === 2; // Bottom row (0-indexed)\n        const cropMarkOffset = CROP_MARK_THICKNESS - 0.75; // Reduced offset (moved back by ~1 pixel)\n        const rightCropMarkOffset = 0.375; // Additional 0.5 pixel offset for right crop marks\n        \n        // Draw crop marks at each corner of the card\n        // Top-left corner (always standard position)\n        page.drawLine({\n          start: { x: cardX - CROP_MARK_LENGTH, y: cardY + cardHeight },\n          end: { x: cardX, y: cardY + cardHeight },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: { x: cardX, y: cardY + cardHeight + CROP_MARK_LENGTH },\n          end: { x: cardX, y: cardY + cardHeight },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        \n        // Top-right corner (offset outward if rightmost card)\n        const rightEdgeX = isRightmostCard ? cardX + cardWidth + cropMarkOffset + rightCropMarkOffset : cardX + cardWidth;\n        page.drawLine({\n          start: { x: rightEdgeX, y: cardY + cardHeight },\n          end: { x: rightEdgeX + CROP_MARK_LENGTH, y: cardY + cardHeight },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: { x: rightEdgeX, y: cardY + cardHeight + CROP_MARK_LENGTH },\n          end: { x: rightEdgeX, y: cardY + cardHeight },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        \n        // Bottom-left corner (offset outward if bottom card)\n        const bottomEdgeY = isBottomCard ? cardY - cropMarkOffset : cardY;\n        page.drawLine({\n          start: { x: cardX - CROP_MARK_LENGTH, y: bottomEdgeY },\n          end: { x: cardX, y: bottomEdgeY },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: { x: cardX, y: bottomEdgeY - CROP_MARK_LENGTH },\n          end: { x: cardX, y: bottomEdgeY },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        \n        // Bottom-right corner (offset outward if rightmost AND bottom card)\n        page.drawLine({\n          start: { x: rightEdgeX, y: bottomEdgeY },\n          end: { x: rightEdgeX + CROP_MARK_LENGTH, y: bottomEdgeY },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: { x: rightEdgeX, y: bottomEdgeY - CROP_MARK_LENGTH },\n          end: { x: rightEdgeX, y: bottomEdgeY },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n      }\n    }\n  }\n\n  const pdfBytes = await pdfDoc.save();\n  return new Blob([pdfBytes], { type: 'application/pdf' });\n};\n\nexport const downloadPDF = (pdfBlob, filename = 'mtg-deck.pdf') => {\n  const url = URL.createObjectURL(pdfBlob);\n  const link = document.createElement('a');\n  link.href = url;\n  link.download = filename;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n  URL.revokeObjectURL(url);\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
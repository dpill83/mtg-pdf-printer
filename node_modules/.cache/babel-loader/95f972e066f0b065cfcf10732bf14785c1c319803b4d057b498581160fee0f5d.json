{"ast":null,"code":"import { PDFDocument, rgb } from 'pdf-lib';\n\n// MTGPrint default settings for Letter paper (8.5\" x 11\") at 300 DPI\n// Letter page: 8.5\" x 11\" = 2550 x 3300 pixels at 300 DPI\nconst LETTER_WIDTH_INCHES = 8.5;\nconst LETTER_HEIGHT_INCHES = 11.0;\nconst DPI = 300;\n\n// Standard Magic card dimensions: 2.5\" x 3.5\" = 750 x 1050 pixels at 300 DPI\nconst CARD_WIDTH_INCHES = 2.5;\nconst CARD_HEIGHT_INCHES = 3.5;\n\n// Convert to points (1 inch = 72 points)\nconst POINTS_PER_INCH = 72;\n\n// Page dimensions in points\nconst PAGE_WIDTH_POINTS = LETTER_WIDTH_INCHES * POINTS_PER_INCH; // 612pt\nconst PAGE_HEIGHT_POINTS = LETTER_HEIGHT_INCHES * POINTS_PER_INCH; // 792pt\n\n// Card dimensions in points\nconst CARD_WIDTH_POINTS = CARD_WIDTH_INCHES * POINTS_PER_INCH; // 180pt\nconst CARD_HEIGHT_POINTS = CARD_HEIGHT_INCHES * POINTS_PER_INCH; // 252pt\n\n// Calculate margins to center 3x3 grid on Letter page\n// Total grid width: 3 cards * 180pt = 540pt\n// Total grid height: 3 cards * 252pt = 756pt\n// Available space: 612pt x 792pt\n// Margins: (612 - 540) / 2 = 36pt horizontal, (792 - 756) / 2 = 18pt vertical\n\nexport const generatePDF = async (cards, paper = {\n  width: 8.5,\n  height: 11.0,\n  unit: 'in'\n}, scale = 100, options = {}) => {\n  // Determine page dimensions in points\n  let widthInches, heightInches;\n  if (paper.unit === 'cm') {\n    widthInches = paper.width / 2.54;\n    heightInches = paper.height / 2.54;\n  } else {\n    widthInches = paper.width;\n    heightInches = paper.height;\n  }\n  const pageWidth = widthInches * POINTS_PER_INCH;\n  const pageHeight = heightInches * POINTS_PER_INCH;\n\n  // Apply scale factor (90-110% range)\n  const scaleFactor = Math.max(90, Math.min(Number(scale), 110)) / 100;\n  const cardWidth = CARD_WIDTH_POINTS * scaleFactor;\n  const cardHeight = CARD_HEIGHT_POINTS * scaleFactor;\n\n  // Recalculate margins for scaled cards to maintain centering\n  const scaledMarginX = (pageWidth - 3 * cardWidth) / 2;\n  const scaledMarginY = (pageHeight - 3 * cardHeight) / 2;\n  const pdfDoc = await PDFDocument.create();\n\n  // Pre-load triangle corner images if black corners are enabled\n  let triangleImages = null;\n  if (options.blackCorners) {\n    try {\n      const triangleUrls = ['/triangle_topleft.png', '/triangle_topright.png', '/triangle_bottomleft.png', '/triangle_bottomright.png'];\n      triangleImages = await Promise.all(triangleUrls.map(async url => {\n        const response = await fetch(url);\n        const arrayBuffer = await response.arrayBuffer();\n        return await pdfDoc.embedPng(new Uint8Array(arrayBuffer));\n      }));\n    } catch (error) {\n      console.error('Failed to load triangle images:', error);\n      triangleImages = null;\n    }\n  }\n\n  // Pre-fetch all images as Uint8Array\n  const imageBytesArr = await Promise.all(cards.map(async card => {\n    try {\n      const response = await fetch(card.imageUrl);\n      const arrayBuffer = await response.arrayBuffer();\n      return new Uint8Array(arrayBuffer);\n    } catch (error) {\n      console.error(`Failed to fetch image for ${card.name}:`, error);\n      return null;\n    }\n  }));\n\n  // Process cards in groups of 9 (3x3 grid per page)\n  for (let i = 0; i < cards.length; i += 9) {\n    const pageCards = cards.slice(i, i + 9);\n    const pageImages = imageBytesArr.slice(i, i + 9);\n    const page = pdfDoc.addPage([pageWidth, pageHeight]);\n\n    // Place cards in 3x3 grid, left-to-right, top-to-bottom\n    for (let j = 0; j < pageCards.length; j++) {\n      const imgBytes = pageImages[j];\n      if (!imgBytes) continue; // Skip if image failed to load\n\n      try {\n        // Embed image (assume PNG)\n        const img = await pdfDoc.embedPng(imgBytes);\n\n        // Calculate grid position (0-2 for row and column)\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n\n        // Calculate card position (PDF coordinates: bottom-left origin)\n        const x = scaledMarginX + col * cardWidth;\n        const y = pageHeight - scaledMarginY - cardHeight - row * cardHeight;\n\n        // Draw the card image\n        page.drawImage(img, {\n          x,\n          y,\n          width: cardWidth,\n          height: cardHeight\n        });\n      } catch (error) {\n        console.error(`Failed to embed image for ${pageCards[j].name}:`, error);\n      }\n    }\n\n    // Draw black corner triangles above the cards if enabled\n    if (options.blackCorners && triangleImages) {\n      const TRIANGLE_SIZE = 32; // 8px triangle size\n      const TRIANGLE_SIZE_POINTS = TRIANGLE_SIZE * (POINTS_PER_INCH / 300); // Convert to points\n\n      for (let j = 0; j < pageCards.length; j++) {\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n\n        // Calculate card position\n        const cardX = scaledMarginX + col * cardWidth;\n        const cardY = pageHeight - scaledMarginY - cardHeight - row * cardHeight;\n\n        // Draw triangle corners at each corner of the card\n        // Top-left corner\n        page.drawImage(triangleImages[0], {\n          x: cardX,\n          y: cardY + cardHeight - TRIANGLE_SIZE_POINTS,\n          width: TRIANGLE_SIZE_POINTS,\n          height: TRIANGLE_SIZE_POINTS\n        });\n\n        // Top-right corner\n        page.drawImage(triangleImages[1], {\n          x: cardX + cardWidth - TRIANGLE_SIZE_POINTS + 0.24 - 0.24,\n          y: cardY + cardHeight - TRIANGLE_SIZE_POINTS,\n          width: TRIANGLE_SIZE_POINTS,\n          height: TRIANGLE_SIZE_POINTS\n        });\n\n        // Bottom-left corner\n        page.drawImage(triangleImages[2], {\n          x: cardX,\n          y: cardY - 0.24 + 0.24,\n          width: TRIANGLE_SIZE_POINTS,\n          height: TRIANGLE_SIZE_POINTS\n        });\n\n        // Bottom-right corner\n        page.drawImage(triangleImages[3], {\n          x: cardX + cardWidth - TRIANGLE_SIZE_POINTS + 0.24 - 0.24,\n          y: cardY - 0.24 + 0.24,\n          width: TRIANGLE_SIZE_POINTS,\n          height: TRIANGLE_SIZE_POINTS\n        });\n      }\n    }\n\n    // Add crop marks if enabled\n    if (options.cropMarks) {\n      // Crop mark dimensions: 1/4\" long, 0.5pt wide for thinner marks\n      const CROP_MARK_LENGTH = 0.25 * POINTS_PER_INCH; // 18pt (1/4\")\n      const CROP_MARK_THICKNESS = 0.5; // 0.5pt wide for thinner crop marks\n\n      // Draw crop marks for each card on the page\n      for (let j = 0; j < pageCards.length; j++) {\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n\n        // Calculate card position\n        const cardX = scaledMarginX + col * cardWidth;\n        const cardY = pageHeight - scaledMarginY - cardHeight - row * cardHeight;\n\n        // Calculate crop mark offset for outermost edges\n        const isRightmostCard = col === 2; // Rightmost column (0-indexed)\n        const isBottomCard = row === 2; // Bottom row (0-indexed)\n        const cropMarkOffset = CROP_MARK_THICKNESS - 0.75; // Reduced offset (moved back by ~1 pixel)\n        const rightCropMarkOffset = 0.375; // Additional 0.5 pixel offset for right crop marks\n\n        // Draw crop marks at each corner of the card\n        // Top-left corner (always standard position)\n        page.drawLine({\n          start: {\n            x: cardX - CROP_MARK_LENGTH,\n            y: cardY + cardHeight\n          },\n          end: {\n            x: cardX,\n            y: cardY + cardHeight\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: {\n            x: cardX,\n            y: cardY + cardHeight + CROP_MARK_LENGTH\n          },\n          end: {\n            x: cardX,\n            y: cardY + cardHeight\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n\n        // Top-right corner (offset outward if rightmost card)\n        const rightEdgeX = isRightmostCard ? cardX + cardWidth + cropMarkOffset + rightCropMarkOffset : cardX + cardWidth;\n        page.drawLine({\n          start: {\n            x: rightEdgeX,\n            y: cardY + cardHeight\n          },\n          end: {\n            x: rightEdgeX + CROP_MARK_LENGTH,\n            y: cardY + cardHeight\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: {\n            x: rightEdgeX,\n            y: cardY + cardHeight + CROP_MARK_LENGTH\n          },\n          end: {\n            x: rightEdgeX,\n            y: cardY + cardHeight\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n\n        // Bottom-left corner (offset outward if bottom card)\n        const bottomEdgeY = isBottomCard ? cardY - cropMarkOffset : cardY;\n        page.drawLine({\n          start: {\n            x: cardX - CROP_MARK_LENGTH,\n            y: bottomEdgeY\n          },\n          end: {\n            x: cardX,\n            y: bottomEdgeY\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: {\n            x: cardX,\n            y: bottomEdgeY - CROP_MARK_LENGTH\n          },\n          end: {\n            x: cardX,\n            y: bottomEdgeY\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n\n        // Bottom-right corner (offset outward if rightmost AND bottom card)\n        page.drawLine({\n          start: {\n            x: rightEdgeX,\n            y: bottomEdgeY\n          },\n          end: {\n            x: rightEdgeX + CROP_MARK_LENGTH,\n            y: bottomEdgeY\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: {\n            x: rightEdgeX,\n            y: bottomEdgeY - CROP_MARK_LENGTH\n          },\n          end: {\n            x: rightEdgeX,\n            y: bottomEdgeY\n          },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n      }\n    }\n  }\n\n  // Add checklist page if requested\n  if (options.printChecklist) {\n    const checklistPage = pdfDoc.addPage([pageWidth, pageHeight]);\n    const font = await pdfDoc.embedFont(PDFDocument.PDFFont ? PDFDocument.PDFFont.COURIER : undefined).catch(() => undefined);\n    const fontSize = 14;\n    const margin = 40;\n    let y = pageHeight - margin;\n    const lineHeight = fontSize + 4;\n    checklistPage.drawText('Checklist', {\n      x: margin,\n      y,\n      size: fontSize + 4,\n      font: font || undefined,\n      color: rgb(0, 0, 0)\n    });\n    y -= lineHeight * 2;\n    cards.forEach(card => {\n      var _card$printings$, _card$printings$2;\n      const setCode = card.setCode || card.printings && ((_card$printings$ = card.printings[0]) === null || _card$printings$ === void 0 ? void 0 : _card$printings$.set_name) || '';\n      const collectorNumber = card.collectorNumber || card.printings && ((_card$printings$2 = card.printings[0]) === null || _card$printings$2 === void 0 ? void 0 : _card$printings$2.collector_number) || '';\n      const line = `${card.quantity} ${card.name} (${setCode}) ${collectorNumber}`;\n      if (y < margin) {\n        y = pageHeight - margin;\n        checklistPage = pdfDoc.addPage([pageWidth, pageHeight]);\n      }\n      checklistPage.drawText(line, {\n        x: margin,\n        y,\n        size: fontSize,\n        font: font || undefined,\n        color: rgb(0, 0, 0)\n      });\n      y -= lineHeight;\n    });\n  }\n  const pdfBytes = await pdfDoc.save();\n  return new Blob([pdfBytes], {\n    type: 'application/pdf'\n  });\n};\nexport const downloadPDF = (pdfBlob, filename = 'mtg-deck.pdf') => {\n  const url = URL.createObjectURL(pdfBlob);\n  const link = document.createElement('a');\n  link.href = url;\n  link.download = filename;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n  URL.revokeObjectURL(url);\n};","map":{"version":3,"names":["PDFDocument","rgb","LETTER_WIDTH_INCHES","LETTER_HEIGHT_INCHES","DPI","CARD_WIDTH_INCHES","CARD_HEIGHT_INCHES","POINTS_PER_INCH","PAGE_WIDTH_POINTS","PAGE_HEIGHT_POINTS","CARD_WIDTH_POINTS","CARD_HEIGHT_POINTS","generatePDF","cards","paper","width","height","unit","scale","options","widthInches","heightInches","pageWidth","pageHeight","scaleFactor","Math","max","min","Number","cardWidth","cardHeight","scaledMarginX","scaledMarginY","pdfDoc","create","triangleImages","blackCorners","triangleUrls","Promise","all","map","url","response","fetch","arrayBuffer","embedPng","Uint8Array","error","console","imageBytesArr","card","imageUrl","name","i","length","pageCards","slice","pageImages","page","addPage","j","imgBytes","img","row","floor","col","x","y","drawImage","TRIANGLE_SIZE","TRIANGLE_SIZE_POINTS","cardX","cardY","cropMarks","CROP_MARK_LENGTH","CROP_MARK_THICKNESS","isRightmostCard","isBottomCard","cropMarkOffset","rightCropMarkOffset","drawLine","start","end","thickness","color","rightEdgeX","bottomEdgeY","printChecklist","checklistPage","font","embedFont","PDFFont","COURIER","undefined","catch","fontSize","margin","lineHeight","drawText","size","forEach","_card$printings$","_card$printings$2","setCode","printings","set_name","collectorNumber","collector_number","line","quantity","pdfBytes","save","Blob","type","downloadPDF","pdfBlob","filename","URL","createObjectURL","link","document","createElement","href","download","body","appendChild","click","removeChild","revokeObjectURL"],"sources":["C:/MTG/mtg-pdf-printer/src/utils/pdfGenerator.js"],"sourcesContent":["import { PDFDocument, rgb } from 'pdf-lib';\n\n// MTGPrint default settings for Letter paper (8.5\" x 11\") at 300 DPI\n// Letter page: 8.5\" x 11\" = 2550 x 3300 pixels at 300 DPI\nconst LETTER_WIDTH_INCHES = 8.5;\nconst LETTER_HEIGHT_INCHES = 11.0;\nconst DPI = 300;\n\n// Standard Magic card dimensions: 2.5\" x 3.5\" = 750 x 1050 pixels at 300 DPI\nconst CARD_WIDTH_INCHES = 2.5;\nconst CARD_HEIGHT_INCHES = 3.5;\n\n// Convert to points (1 inch = 72 points)\nconst POINTS_PER_INCH = 72;\n\n// Page dimensions in points\nconst PAGE_WIDTH_POINTS = LETTER_WIDTH_INCHES * POINTS_PER_INCH;  // 612pt\nconst PAGE_HEIGHT_POINTS = LETTER_HEIGHT_INCHES * POINTS_PER_INCH; // 792pt\n\n// Card dimensions in points\nconst CARD_WIDTH_POINTS = CARD_WIDTH_INCHES * POINTS_PER_INCH;  // 180pt\nconst CARD_HEIGHT_POINTS = CARD_HEIGHT_INCHES * POINTS_PER_INCH; // 252pt\n\n// Calculate margins to center 3x3 grid on Letter page\n// Total grid width: 3 cards * 180pt = 540pt\n// Total grid height: 3 cards * 252pt = 756pt\n// Available space: 612pt x 792pt\n// Margins: (612 - 540) / 2 = 36pt horizontal, (792 - 756) / 2 = 18pt vertical\n\nexport const generatePDF = async (cards, paper = { width: 8.5, height: 11.0, unit: 'in' }, scale = 100, options = {}) => {\n  // Determine page dimensions in points\n  let widthInches, heightInches;\n  if (paper.unit === 'cm') {\n    widthInches = paper.width / 2.54;\n    heightInches = paper.height / 2.54;\n  } else {\n    widthInches = paper.width;\n    heightInches = paper.height;\n  }\n  const pageWidth = widthInches * POINTS_PER_INCH;\n  const pageHeight = heightInches * POINTS_PER_INCH;\n\n  // Apply scale factor (90-110% range)\n  const scaleFactor = Math.max(90, Math.min(Number(scale), 110)) / 100;\n  const cardWidth = CARD_WIDTH_POINTS * scaleFactor;\n  const cardHeight = CARD_HEIGHT_POINTS * scaleFactor;\n\n  // Recalculate margins for scaled cards to maintain centering\n  const scaledMarginX = (pageWidth - (3 * cardWidth)) / 2;\n  const scaledMarginY = (pageHeight - (3 * cardHeight)) / 2;\n\n  const pdfDoc = await PDFDocument.create();\n\n  // Pre-load triangle corner images if black corners are enabled\n  let triangleImages = null;\n  if (options.blackCorners) {\n    try {\n      const triangleUrls = [\n        '/triangle_topleft.png',\n        '/triangle_topright.png',\n        '/triangle_bottomleft.png',\n        '/triangle_bottomright.png'\n      ];\n      \n      triangleImages = await Promise.all(\n        triangleUrls.map(async (url) => {\n          const response = await fetch(url);\n          const arrayBuffer = await response.arrayBuffer();\n          return await pdfDoc.embedPng(new Uint8Array(arrayBuffer));\n        })\n      );\n    } catch (error) {\n      console.error('Failed to load triangle images:', error);\n      triangleImages = null;\n    }\n  }\n\n  // Pre-fetch all images as Uint8Array\n  const imageBytesArr = await Promise.all(\n    cards.map(async (card) => {\n      try {\n        const response = await fetch(card.imageUrl);\n        const arrayBuffer = await response.arrayBuffer();\n        return new Uint8Array(arrayBuffer);\n      } catch (error) {\n        console.error(`Failed to fetch image for ${card.name}:`, error);\n        return null;\n      }\n    })\n  );\n\n  // Process cards in groups of 9 (3x3 grid per page)\n  for (let i = 0; i < cards.length; i += 9) {\n    const pageCards = cards.slice(i, i + 9);\n    const pageImages = imageBytesArr.slice(i, i + 9);\n    const page = pdfDoc.addPage([pageWidth, pageHeight]);\n\n    // Place cards in 3x3 grid, left-to-right, top-to-bottom\n    for (let j = 0; j < pageCards.length; j++) {\n      const imgBytes = pageImages[j];\n      if (!imgBytes) continue; // Skip if image failed to load\n\n      try {\n        // Embed image (assume PNG)\n        const img = await pdfDoc.embedPng(imgBytes);\n        \n        // Calculate grid position (0-2 for row and column)\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n        \n        // Calculate card position (PDF coordinates: bottom-left origin)\n        const x = scaledMarginX + (col * cardWidth);\n        const y = pageHeight - scaledMarginY - cardHeight - (row * cardHeight);\n        \n        // Draw the card image\n        page.drawImage(img, {\n          x,\n          y,\n          width: cardWidth,\n          height: cardHeight,\n        });\n      } catch (error) {\n        console.error(`Failed to embed image for ${pageCards[j].name}:`, error);\n      }\n    }\n\n    // Draw black corner triangles above the cards if enabled\n    if (options.blackCorners && triangleImages) {\n      const TRIANGLE_SIZE = 32; // 8px triangle size\n      const TRIANGLE_SIZE_POINTS = TRIANGLE_SIZE * (POINTS_PER_INCH / 300); // Convert to points\n      \n      for (let j = 0; j < pageCards.length; j++) {\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n        \n        // Calculate card position\n        const cardX = scaledMarginX + (col * cardWidth);\n        const cardY = pageHeight - scaledMarginY - cardHeight - (row * cardHeight);\n        \n        // Draw triangle corners at each corner of the card\n        // Top-left corner\n        page.drawImage(triangleImages[0], {\n          x: cardX,\n          y: cardY + cardHeight - TRIANGLE_SIZE_POINTS,\n          width: TRIANGLE_SIZE_POINTS,\n          height: TRIANGLE_SIZE_POINTS,\n        });\n        \n        // Top-right corner\n        page.drawImage(triangleImages[1], {\n          x: cardX + cardWidth - TRIANGLE_SIZE_POINTS + 0.24 - 0.24,\n          y: cardY + cardHeight - TRIANGLE_SIZE_POINTS,\n          width: TRIANGLE_SIZE_POINTS,\n          height: TRIANGLE_SIZE_POINTS,\n        });\n        \n        // Bottom-left corner\n        page.drawImage(triangleImages[2], {\n          x: cardX,\n          y: cardY - 0.24 + 0.24,\n          width: TRIANGLE_SIZE_POINTS,\n          height: TRIANGLE_SIZE_POINTS,\n        });\n        \n        // Bottom-right corner\n        page.drawImage(triangleImages[3], {\n          x: cardX + cardWidth - TRIANGLE_SIZE_POINTS + 0.24 - 0.24,\n          y: cardY - 0.24 + 0.24,\n          width: TRIANGLE_SIZE_POINTS,\n          height: TRIANGLE_SIZE_POINTS,\n        });\n      }\n    }\n\n    // Add crop marks if enabled\n    if (options.cropMarks) {\n      // Crop mark dimensions: 1/4\" long, 0.5pt wide for thinner marks\n      const CROP_MARK_LENGTH = 0.25 * POINTS_PER_INCH; // 18pt (1/4\")\n      const CROP_MARK_THICKNESS = 0.5; // 0.5pt wide for thinner crop marks\n      \n      // Draw crop marks for each card on the page\n      for (let j = 0; j < pageCards.length; j++) {\n        const row = Math.floor(j / 3);\n        const col = j % 3;\n        \n        // Calculate card position\n        const cardX = scaledMarginX + (col * cardWidth);\n        const cardY = pageHeight - scaledMarginY - cardHeight - (row * cardHeight);\n        \n        // Calculate crop mark offset for outermost edges\n        const isRightmostCard = col === 2; // Rightmost column (0-indexed)\n        const isBottomCard = row === 2; // Bottom row (0-indexed)\n        const cropMarkOffset = CROP_MARK_THICKNESS - 0.75; // Reduced offset (moved back by ~1 pixel)\n        const rightCropMarkOffset = 0.375; // Additional 0.5 pixel offset for right crop marks\n        \n        // Draw crop marks at each corner of the card\n        // Top-left corner (always standard position)\n        page.drawLine({\n          start: { x: cardX - CROP_MARK_LENGTH, y: cardY + cardHeight },\n          end: { x: cardX, y: cardY + cardHeight },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: { x: cardX, y: cardY + cardHeight + CROP_MARK_LENGTH },\n          end: { x: cardX, y: cardY + cardHeight },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        \n        // Top-right corner (offset outward if rightmost card)\n        const rightEdgeX = isRightmostCard ? cardX + cardWidth + cropMarkOffset + rightCropMarkOffset : cardX + cardWidth;\n        page.drawLine({\n          start: { x: rightEdgeX, y: cardY + cardHeight },\n          end: { x: rightEdgeX + CROP_MARK_LENGTH, y: cardY + cardHeight },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: { x: rightEdgeX, y: cardY + cardHeight + CROP_MARK_LENGTH },\n          end: { x: rightEdgeX, y: cardY + cardHeight },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        \n        // Bottom-left corner (offset outward if bottom card)\n        const bottomEdgeY = isBottomCard ? cardY - cropMarkOffset : cardY;\n        page.drawLine({\n          start: { x: cardX - CROP_MARK_LENGTH, y: bottomEdgeY },\n          end: { x: cardX, y: bottomEdgeY },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: { x: cardX, y: bottomEdgeY - CROP_MARK_LENGTH },\n          end: { x: cardX, y: bottomEdgeY },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        \n        // Bottom-right corner (offset outward if rightmost AND bottom card)\n        page.drawLine({\n          start: { x: rightEdgeX, y: bottomEdgeY },\n          end: { x: rightEdgeX + CROP_MARK_LENGTH, y: bottomEdgeY },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n        page.drawLine({\n          start: { x: rightEdgeX, y: bottomEdgeY - CROP_MARK_LENGTH },\n          end: { x: rightEdgeX, y: bottomEdgeY },\n          thickness: CROP_MARK_THICKNESS,\n          color: rgb(0.7, 0.7, 0.7)\n        });\n      }\n    }\n  }\n\n  // Add checklist page if requested\n  if (options.printChecklist) {\n    const checklistPage = pdfDoc.addPage([pageWidth, pageHeight]);\n    const font = await pdfDoc.embedFont(PDFDocument.PDFFont ? PDFDocument.PDFFont.COURIER : undefined).catch(() => undefined);\n    const fontSize = 14;\n    const margin = 40;\n    let y = pageHeight - margin;\n    const lineHeight = fontSize + 4;\n    checklistPage.drawText('Checklist', {\n      x: margin,\n      y,\n      size: fontSize + 4,\n      font: font || undefined,\n      color: rgb(0, 0, 0),\n    });\n    y -= lineHeight * 2;\n    cards.forEach(card => {\n      const setCode = card.setCode || (card.printings && card.printings[0]?.set_name) || '';\n      const collectorNumber = card.collectorNumber || (card.printings && card.printings[0]?.collector_number) || '';\n      const line = `${card.quantity} ${card.name} (${setCode}) ${collectorNumber}`;\n      if (y < margin) {\n        y = pageHeight - margin;\n        checklistPage = pdfDoc.addPage([pageWidth, pageHeight]);\n      }\n      checklistPage.drawText(line, {\n        x: margin,\n        y,\n        size: fontSize,\n        font: font || undefined,\n        color: rgb(0, 0, 0),\n      });\n      y -= lineHeight;\n    });\n  }\n\n  const pdfBytes = await pdfDoc.save();\n  return new Blob([pdfBytes], { type: 'application/pdf' });\n};\n\nexport const downloadPDF = (pdfBlob, filename = 'mtg-deck.pdf') => {\n  const url = URL.createObjectURL(pdfBlob);\n  const link = document.createElement('a');\n  link.href = url;\n  link.download = filename;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n  URL.revokeObjectURL(url);\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}